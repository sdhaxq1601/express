<html>

<head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
    <meta name="msapplication-TileColor" content="#001">
    <meta name="theme-color" content="#001">
    <title><%=n%></title>
    <style>
        *{margin:0;padding:0;border:0 solid #000;}
    form{padding-top:3em;
        padding-left:2em;}
    input{color: #f0f0f0;
        font-size: 10px;
        font-size:1em;}
    #f1{width:90px;
      height:10px;
      opacity:.1;}
    #submit{font-size:0.8em;
      opacity:.1;}
    img{width:80%;}
    .hide{display:none;}
    #log{
      color:#433;
      position:fixed;
      bottom:0;
    }
    .func{
        position:fixed;
        bottom:0;
        right:0;
        list-style: none;        
    }
    .func li{
        display:inline-block;
        background: #111;
        opacity:0.8;
        width:16vmin;
        height:16vmin;
        margin:2px;
    }
    #undo::before{
        content:"";
        position:absolute;
        background: #8c8cef;
        width:8vmin;
        height:2vmin;
        border-radius: 1vmin;
        /* border:1px solid red; */
        bottom: 32%;
        left: 16%;
        transform: translateX(-50%) rotate(45deg);
    }
    #undo::after{
        content:"";
        position:absolute;
        background: #8c8cef;
        width:8vmin;
        height:2vmin;
        border-radius: 1vmin;
        /* border:1px solid red; */
        top: 32%;
        left: 16%;
        transform: translateX(-50%) rotate(-45deg);
    }
    #redo::before{
        content:"";
        position:absolute;
        background: #8cef8c;
        width:8vmin;
        height:2vmin;
        border-radius: 1vmin;
        /* border:1px solid red; */
        top: 32%;
        left: 50%;
        transform: translateX(-50%) rotate(45deg);
    }
    #redo::after{
        content:"";
        position:absolute;
        background: #8cef8c;
        width:8vmin;
        height:2vmin;
        border-radius: 1vmin;
        /* border:1px solid red; */
        bottom: 32%;
        left: 50%;
        transform: translateX(-50%) rotate(-45deg);
    }
    #clear::before{
        content:"";
        position:absolute;
        background: #88ccef;
        width:16vmin;
        height:2vmin;
        border-radius: 1vmin;
        /* border:1px solid red; */
        top:50%;
        transform: translateY(-50%) rotate(45deg);
    }
    #clear::after{
        content:"";
        position:absolute;
        background: #88ccef;
        width:16vmin;
        height:2vmin;
        border-radius: 1vmin;
        /* border:1px solid red; */
        top:50%;
        transform: translateY(-50%) rotate(-45deg);
    }
    </style>
</head>

<body> 
    <div id='' class=''>
        <canvas id="can" width="360" height="360" style="background:#000;margin-top:0vh;">
        </canvas>
        <div class="func" id="func">
            <ul>
                <li id='undo'></li>
                <li id='redo'></li>
                <li id='clear'></li>
            </ul>
        </div>
    </div>
    <script>
        let acts = []//record every action line count, asyn with step
        let step = 0
        let lines = [], line = {}, points = []
        let color = "#fff", width = 2, isClear = false
        let timeoutId
        const can = document.getElementById("can")
        can.width = window.innerWidth
        let winH = window.innerHeight
        let cx = can.getContext("2d")
        cx.strokeStyle = "#fff"
        let func = document.getElementById("func")
        func.addEventListener('touchmove', (e) => { e.preventDefault() })
        let sx, sy
        let log, _log
        let endTime = 0
        let undo, redo, clear
        const draw = l => {
            if (l.length < 2) return
            cx.lineWidth = l.width
            cx.strokeStyle = l.color
            cx.beginPath()
            cx.moveTo(l.points[0].sx, l.points[0].sy)
            l.points.slice(1).forEach(i => cx.lineTo(i.sx, i.sy))
            cx.stroke()
        }
        undo = () => {
            cx.clearRect(0, 0, can.offsetWidth, can.offsetHeight)
            step--
            log('undo')
            acts.slice(lastClearAct(acts, step) + 1, step).forEach(i => {
                i.lines.forEach(l => draw(l))
            })
        }
        redo = () => {
            cx.clearRect(0, 0, can.offsetWidth, can.offsetHeight)
            step++
            log('redo')
            console.log(acts.slice(-1)[0])
            acts.slice(lastClearAct(acts, step) + 1, step).forEach(i => {
                i.lines.forEach(l => draw(l))
            })            
        }
        clear = () => {
            if (acts[step - 1].isClear) return
            step++
            acts.push({ isClear: true, lines: [] })
            log('clear')
            cx.clearRect(0, 0, can.offsetWidth, can.offsetHeight)
        }
        window.onload = (e) => {
            can.height = window.innerHeight
            cx.strokeStyle = "#fff"
            window.scrollTo(0, 1000)
            //can.requestFullScreen()
            _log = document.getElementById("log")
            log = (s) => {
                _log.innerText = s + "_" + acts.length + "_" + step
            }
            //log(window.outerHeight+" "+window.innerHeight)
            document.addEventListener('click', e => {
                let id = e.target.id
                if (id == "redo" && step < acts.length){
                    let i
                    for(i=step;i<acts.length;i++){
                        if(!acts[i].isClear){
                            step=i;
                            break;
                        }
                    }
                    console.log(i,acts.length)
                    if(i===acts.length)return
                    redo()
                }
                if (id == "undo" && step > 0){
                    let i
                    for(i=step;i>0;i--){
                        if(!acts[i-2].isClear){
                            step=i;
                            break;
                        }
                    }
                    if(i===0)return
                    undo()
                }
                if (id == "clear") clear()
                console.log(e.target)
            })
        }

        window.onresize = (e) => {
            can.width = window.innerWidth
            can.height = window.innerHeight
            undo()
            redo()
        }
        can.addEventListener("touchstart", (e) => {
            log("touchstart")
            e.preventDefault();
            //log.innerText=`${can.offsetTop}=${can.clientTop+"S"}`
            console.log(e.touches[0])
            clearTimeout(timeoutId)
            sx = e.touches[0].pageX - can.offsetLeft
            sy = e.touches[0].pageY - can.offsetTop
            if (new Date().getTime() - endTime > 1000) {

            } else {

            }
            cx.lineWidth = 1
            cx.beginPath()
            cx.moveTo(sx, sy)
            points = [{ sx, sy }]
        }, { passive: false })

        can.addEventListener("touchmove", (e) => {
            endTime = new Date().getTime()
            //log("touchmove")
            //e.preventDefault();
            sx = e.touches[0].pageX - can.offsetLeft
            sy = e.touches[0].pageY - can.offsetTop
            //cx.clearRect(0,0,can.offsetWidth,can.offsetHeight)
            //cx.beginPath()
            //cx.moveTo(sx,sy)
            cx.lineTo(sx, sy)
            cx.stroke()
            points.push({ sx, sy })
            //e.stopPropagation();
        }, { passive: false })

        can.addEventListener("touchend", (e) => {
            endTime = new Date().getTime()
            console.log(e.touches[0])
            cx.stroke()
            if (acts.length > step) {
                acts = acts.splice(0, step)
            }
            lines.push({ points, color, width })
            timeoutId = setTimeout(() => {
                acts.push({ isClear, lines })
                step++
                lines = []
                log('TIMEOUT')
            }, 500);
            log("touchend")
            //e.stopPropagation();
        }, { passive: false })
    </script>
    <script id='functions'>
        function lastEmptyArray(arr, end) {
            var l = arr.length
            if (typeof end == 'number' && end < l) l = end

            for (var i = l - 1; i >= 0; i--)
                if (arr[i].length == 0) return i
            return -1
        }
        function lastClearAct(arr, end) {
            var l = arr.length
            if (typeof end == 'number' && end < l) l = end

            for (var i = l - 1; i >= 0; i--)
                if (arr[i].isClear) return i
            return -1
        }
    </script>
    <div id='log' class=''></div>
</body>

</html>